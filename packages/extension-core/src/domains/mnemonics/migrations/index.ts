import keyring from "@polkadot/ui-keyring"
import { assert } from "@polkadot/util"
import md5 from "blueimp-md5"

import { Migration, MigrationFunction } from "../../../libs/migrations/types"
import { appStore } from "../../app/store.app"
import { decryptMnemonic } from "../legacy/helpers"
import {
  createLegacySeedPhraseStore,
  createLegacyVerifierCertificateMnemonicStore,
} from "../legacy/store"
import { MnemonicSource, encryptMnemonic, mnemonicsStore } from "../store"

type AccountType = {
  [K in keyof typeof AccountTypes]: (typeof AccountTypes)[K]
}[keyof typeof AccountTypes]

const AccountTypes = {
  TALISMAN: "TALISMAN", // mnemonic generated by Talisman
  LEGACY_ROOT: "ROOT", // legacy, deprecated
  DERIVED: "DERIVED",
  SEED_STORED: "SEED_STORED", // used for an imported mnemonic which is stored
} as const

const mnemonicAccountTypes: AccountType[] = [
  AccountTypes.TALISMAN,
  AccountTypes.LEGACY_ROOT,
  AccountTypes.SEED_STORED,
]

const getMnemonicHash = async (cipher: string, password: string) => {
  const { val: mnemonic, err } = await decryptMnemonic(cipher, password)
  if (err) throw new Error(mnemonic)
  const hash = md5(mnemonic)

  const encrypted = await encryptMnemonic(mnemonic, password)
  return { hash, encrypted }
}

export const migrateSeedStoreToMultiple: Migration = {
  forward: new MigrationFunction(async (context) => {
    const legacyStore = createLegacySeedPhraseStore()
    const legacyData = await legacyStore.get()
    const legacyCipher = legacyData.cipher
    if (!legacyCipher) return

    const { password } = context
    assert(password, "Password not found, unable to perform migration")

    const { encrypted: cipher, hash: id } = await getMnemonicHash(legacyCipher, password)

    await mnemonicsStore.set({
      [id]: {
        id,
        name: "My Recovery Phrase",
        source: MnemonicSource.Legacy,
        cipher,
        confirmed: legacyData.confirmed,
      },
    })

    // get all accounts which have been derived from this recovery phrase, and add derivedMnemonicId to the metadata

    const allAccounts = keyring.getAccounts()
    const parentAccount = allAccounts.find(
      ({ meta: { origin } }) => origin && mnemonicAccountTypes.includes(origin as AccountType)
    )
    const derivedAccounts = allAccounts.filter(
      ({ meta: { parent, origin } }) =>
        parent === parentAccount?.address && origin === AccountTypes.DERIVED
    )
    const migrationAccounts = [...derivedAccounts, parentAccount]

    migrationAccounts.forEach((account) => {
      if (account) {
        keyring.saveAccountMeta(keyring.getPair(account.address), {
          ...account.meta,
          derivedMnemonicId: id,
        })
      }
    })

    // if a verifier certificate exists, add it to the new seed store
    const legacyVerifierCertificateStore = createLegacyVerifierCertificateMnemonicStore()
    const legacyVCData = await legacyVerifierCertificateStore.get()
    if (legacyVCData.cipher) {
      let appStoreVCId = id
      if (legacyVCData.cipher !== legacyData.cipher) {
        const { encrypted: vcCipher, hash: vcId } = await getMnemonicHash(
          legacyVCData.cipher,
          password
        )

        appStoreVCId = vcId

        await mnemonicsStore.set({
          [vcId]: {
            ...legacyVCData,
            id: vcId,
            name: "Polkadot Vault Verifier Certificate",
            source: MnemonicSource.Legacy,
            cipher: vcCipher,
            confirmed: true, // verifier certificate is always confirmed, because it was imported manually
          },
        })
      }

      // set the app store to use the new id
      await appStore.set({ vaultVerifierCertificateMnemonicId: appStoreVCId })
    }
  }),
  // no way back
}

export const migrations = {
  0: migrateSeedStoreToMultiple,
}
