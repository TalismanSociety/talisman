import { appStore } from "@core/domains/app"
import { Migration, MigrationFunction } from "@core/libs/migrations/types"
import keyring from "@polkadot/ui-keyring"
import { nanoid } from "nanoid"

import {
  createLegacySeedPhraseStore,
  createLegacyVerifierCertificateMnemonicStore,
} from "../legacy/store"
import { seedPhraseStore } from "../store"

enum SOURCES {
  Imported = "imported",
  Generated = "generated",
  Legacy = "legacy",
  Vault = "vault",
}

type AccountType = {
  [K in keyof typeof AccountTypes]: (typeof AccountTypes)[K]
}[keyof typeof AccountTypes]

const AccountTypes = {
  TALISMAN: "TALISMAN", // mnemonic generated by Talisman
  LEGACY_ROOT: "ROOT", // legacy, deprecated
  DERIVED: "DERIVED",
  SEED_STORED: "SEED_STORED", // used for an imported mnemonic which is stored
} as const

const storedSeedAccountTypes: AccountType[] = [
  AccountTypes.TALISMAN,
  AccountTypes.LEGACY_ROOT,
  AccountTypes.SEED_STORED,
]

export const migrateSeedStoreToMultiple: Migration = {
  forward: new MigrationFunction(async () => {
    const legacyStore = createLegacySeedPhraseStore()
    const legacyData = await legacyStore.get()
    const id = nanoid()
    await seedPhraseStore.set({
      [id]: { id, name: "My Recovery Phrase", source: SOURCES.Legacy, ...legacyData },
    })
    // get all accounts which have been derived from this seed phrase, and add derivedMnemonicId to the metadata

    const allAccounts = keyring.getAccounts()
    const seedAccount = allAccounts.find(
      ({ meta: { origin } }) => origin && storedSeedAccountTypes.includes(origin as AccountType)
    )
    const derivedAccounts = allAccounts.filter(
      ({ meta: { parent, origin } }) =>
        parent === seedAccount?.address && origin === AccountTypes.DERIVED
    )
    const migrationAccounts = [...derivedAccounts, seedAccount]

    migrationAccounts.forEach((account) => {
      if (account) {
        keyring.saveAccountMeta(keyring.getPair(account.address), {
          ...account.meta,
          derivedMnemonicId: id,
        })
      }
    })

    // if a verifier certificate exists, add it to the new seed store
    const legacyVerifierCertificateStore = createLegacyVerifierCertificateMnemonicStore()
    const legacyVCData = await legacyVerifierCertificateStore.get()
    if (legacyVCData.cipher) {
      let appStoreVCId = id
      // todo tell the appstore which one is the vc cert
      if (legacyVCData.cipher !== legacyData.cipher) {
        const vcId = nanoid()
        appStoreVCId = vcId
        await seedPhraseStore.set({
          [vcId]: {
            id: vcId,
            name: "My Recovery Phrase",
            source: SOURCES.Vault,
            ...legacyVCData,
          },
        })
      }
      await appStore.set({ vaultVerifierCertificateMnemonicId: appStoreVCId })
    }
  }),
  // no way back
}

export const migrations = {
  0: migrateSeedStoreToMultiple,
}
